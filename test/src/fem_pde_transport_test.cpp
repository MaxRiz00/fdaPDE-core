// This file is part of fdaPDE, a C++ library for physics-informed
// spatial and functional data analysis.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <gtest/gtest.h>   // testing framework
#include <cstddef>

#include <fdaPDE/utils.h>
#include <fdaPDE/fields.h>
#include <fdaPDE/mesh.h>
#include <fdaPDE/finite_elements.h>
using fdapde::core::Element;
using fdapde::core::Integrator;
using fdapde::core::LagrangianBasis;
using fdapde::core::FEM;
using fdapde::core::MatrixConst;
using fdapde::core::MatrixPtr;
using fdapde::core::ScalarPtr;
using fdapde::core::VectorPtr;

using fdapde::core::PDE;
using fdapde::core::ScalarField;
using fdapde::core::advection;
using fdapde::core::reaction;
using fdapde::core::diffusion;
using fdapde::core::laplacian;
using fdapde::core::dt;
using fdapde::core::fem_order;
using fdapde::core::make_pde;
using fdapde::core::PDEparameters;
using fdapde::core::DiscretizedMatrixField;
using fdapde::core::DiscretizedVectorField;
using fdapde::core::Divergence;

#include "utils/mesh_loader.h"
using fdapde::testing::MeshLoader;
#include "utils/utils.h"
using fdapde::testing::almost_equal;
using fdapde::testing::DOUBLE_TOLERANCE;
using fdapde::testing::read_csv;

// #include <iomanip>
#include <string>

// tests for Advection Dominated Elliptic Partial Differential Equations
TEST(transport_test, TestCase0) {
    constexpr std::size_t femOrder = 1;

    // define exact solution
    auto solutionExpr = [](SVector<2> x) -> double {
        return 3*sin(x[0]) + 2*x[1];
    };

    SVector<2> b;  b << 1., 1.;
    double mu = 1e-9;

    // non-zero forcing term
    auto forcingExpr = [&mu, &b](SVector<2> x) -> double {
        return 2*b[1] + 3*b[0]*cos(x[0]) + 3*mu*sin(x[0]);
    };
    ScalarField<2> forcing(forcingExpr);   // wrap lambda expression in ScalarField object

    PDEparameters<decltype(mu), decltype(b)>::destroyInstance();
    PDEparameters<decltype(mu), decltype(b)> &PDEparams =
            PDEparameters<decltype(mu), decltype(b)>::getInstance(mu, b);

    auto L = - mu * laplacian<FEM>() + advection<FEM>(b);
    MeshLoader<Mesh2D> unit_square("unit_square_32");

    PDE< decltype(unit_square.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(mu),
            decltype(b)> pde_( unit_square.mesh, L); //, forcing);
    pde_.set_forcing(forcing);

    // compute boundary condition and exact solution
    DMatrix<double> nodes_ = pde_.dof_coords();
    DMatrix<double> dirichletBC(nodes_.rows(), 1);
    DMatrix<double> solution_ex(nodes_.rows(), 1);

    // set exact sol & dirichlet conditions
    for (int i = 0; i < nodes_.rows(); ++i) {
        solution_ex(i) = solutionExpr(nodes_.row(i));
        dirichletBC(i) = solutionExpr(nodes_.row(i));
    }
    pde_.set_dirichlet_bc(dirichletBC);
    pde_.set_stab_param(1.0);
    // init solver and solve differential problem
    pde_.init();
    pde_.solve();

    // check computed error
    DMatrix<double> error_ = solution_ex - pde_.solution();
    double error_L2 = (pde_.mass() * error_.cwiseProduct(error_)).sum();
    EXPECT_TRUE(error_L2 < 1e-7);

//    std::cout << "error_L2 = " << std::setprecision(17) << error_L2 << std::endl;
//    //storing solution
//    std::ofstream file("fdaPDE_SUPG_sol.txt");
//    if (file.is_open()){
//        for(int i = 0; i < pde_.solution().rows(); ++i)
//            file << pde_.solution()(i) << '\n';
//        file.close();
//    } else {
//        std::cerr << "transport test unable to save solution" << std::endl;
//    }
}

/*
TEST(transport_test, TestCase1) {

    constexpr std::size_t femOrder = 1;

    // define exact solution
    SVector<2> b;
    b << 1., 0.;
    double nu = 1e-9;
    // double c = 0.;

    auto solutionExpr = [&nu](SVector<2> x) -> double {
        return x[0]*x[1]*x[1] - x[1]*x[1]*exp((2*(x[0] - 1))/nu) - x[0]*exp(3*(x[1] - 1)/nu) + exp((2*(x[0] - 1) + 3*(x[1] - 1))/nu);
    };

    // forcing term
    using std::exp;
    auto forcingExpr = [&nu, &b](SVector<2> x) -> double {
        return b[0]*(x[1]*x[1] - exp((3*x[1] - 3)/nu) - 2*x[1]*x[1]*exp((2*x[0] - 2)/nu)/nu + 2*exp((2*x[0] + 3*x[1] - 5)/nu)/nu) + b[1]*(2*x[0]*x[1] - 2*x[1]*exp((2*x[0] - 2)/nu) - 3*x[0]*exp((3*x[1] - 3)/nu)/nu + 3*exp((2*x[0] + 3*x[1] - 5)/nu)/nu) - nu*(2*x[0] - 2*exp((2*x[0] - 2)/nu) - 9*x[0]*exp((3*x[1] - 3)/nu)/(nu*nu) - 4*x[1]*x[1]*exp((2*x[0] - 2)/nu)/(nu*nu) + 13*exp((2*x[0] + 3*x[1] - 5)/nu)/(nu*nu));
    };
    ScalarField<2> forcing(forcingExpr);

    PDEparameters<decltype(nu), decltype(b)>::destroyInstance();
    PDEparameters<decltype(nu), decltype(b)> &PDEparams =
            PDEparameters<decltype(nu), decltype(b)>::getInstance(nu, b);

    auto L = - nu * laplacian<FEM>() + advection<FEM>(b); // + reaction<FEM>(c);

    MeshLoader<Mesh2D> unit_square("unit_square_32");

    PDE< decltype(unit_square.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(nu),
            decltype(b)> pde_( unit_square.mesh, L, forcing);

    // compute boundary condition and exact solution
    DMatrix<double> nodes_ = pde_.dof_coords();
    DMatrix<double> dirichletBC(nodes_.rows(), 1);
    DMatrix<double> solution_ex(nodes_.rows(), 1);

    // set exact sol & dirichlet conditions
    for (int i = 0; i < nodes_.rows(); ++i) {
        solution_ex(i) = solutionExpr(nodes_.row(i));
        dirichletBC(i) = solutionExpr(nodes_.row(i));
    }
    pde_.set_dirichlet_bc(dirichletBC);
    pde_.set_stab_param(1.075);

    // init solver and solve differential problem
    pde_.init();
    pde_.solve();

    // check computed error
    DMatrix<double> error_ = solution_ex - pde_.solution();
    double error_L2 = (pde_.mass() * error_.cwiseProduct(error_)).sum();
    EXPECT_TRUE(error_L2 < 1e-3);

//    std::cout << "error_L2 = " << std::setprecision(17) << error_L2 << std::endl;
//    //storing solution
//    std::ofstream file("fdaPDE_SUPG_sol.txt");
//    if (file.is_open()){
//        for(int i = 0; i < pde_.solution().rows(); ++i)
//            file << pde_.solution()(i) << '\n';
//        file.close();
//    } else {
//        std::cerr << "transport test unable to save solution" << std::endl;
//    }

}

TEST(transport_test, TestCase2){
    constexpr std::size_t femOrder = 1;

    // define domain
    MeshLoader<Mesh2D> domain("unit_square_32");

    // define vector field containing transport data
    VectorField<2> b_callable;
    b_callable[0] = [](SVector<2> x) -> double { return std::pow(x[1], 2) + 1; };   // y^2 + 1
    b_callable[1] = [](SVector<2> x) -> double { return 2 * x[0]; };                // 2*x

    Integrator<FEM, 2, femOrder> integrator;
    DMatrix<double> quad_nodes = integrator.quadrature_nodes(domain.mesh);

    DMatrix<double, Eigen::RowMajor> b_data(quad_nodes.rows(), 2);
    for(int i = 0; i < quad_nodes.rows(); i++) {
        b_data.row(i) = b_callable(SVector<2>(quad_nodes.row(i)));
    }

    // construct it together with its divergence
    ScalarField<2> div_b_callable = div(b_callable);
    DVector<double> div_b_data(quad_nodes.rows());
    for(int i = 0; i < quad_nodes.rows(); i++) {
        div_b_data(i) = div_b_callable(SVector<2>(quad_nodes.row(i)));
    }

    DiscretizedVectorField<2,2> b_discretized(b_data, div_b_data);

    // coefficients
    double mu = 1e-9;

    // non-zero forcing term
    auto forcingExpr = [](SVector<2> x) -> double { return 1.; };
    ScalarField<2> forcing(forcingExpr);   // wrap lambda expression in ScalarField object

    PDEparameters<decltype(mu), decltype(b_discretized)> &PDEparams =
            PDEparameters<decltype(mu), decltype(b_discretized)>::getInstance(mu, b_discretized);

    // define differential operator
    auto L = -mu*laplacian<FEM>() + advection<FEM>(b_discretized);

    PDE< decltype(domain.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(mu),
            decltype(b_discretized)> pde_( domain.mesh, L, forcing );

    // compute boundary condition and exact solution
    DMatrix<double> nodes_ = pde_.dof_coords();
    DMatrix<double> dirichletBC(nodes_.rows(), 1);

    // set dirichlet conditions
    for (int i = 0; i < nodes_.rows(); ++i) {
        dirichletBC(i) = 0.;
    }
    pde_.set_dirichlet_bc(dirichletBC);
    pde_.set_stab_param(2.285);

    // init solver and solve differential problem
    pde_.init();
    pde_.solve();

//    //storing solution
//    {
//    std::ofstream file("fdaPDE_SUPG_sol.txt");
//    if (file.is_open()){
//        for(int i = 0; i < pde_.solution().rows(); ++i)
//            file << pde_.solution()(i) << '\n';
//        file.close();
//    } else {
//        std::cerr << "transport test unable to save solution" << std::endl;
//    }
//    }

    std::vector<double> expected({
        -4.38473e-34, -2.03556e-34, -2.64195e-34, -3.51364e-34, -4.41444e-34, -5.12436e-34, -5.50362e-34, -5.54015e-34, -5.34861e-34, -5.10577e-34, -4.94903e-34, -4.90593e-34, -4.91346e-34, -4.91075e-34, -4.89877e-34, -4.89126e-34, -4.88609e-34, -4.88209e-34, -4.87902e-34, -4.87665e-34, -4.87481e-34, -4.87339e-34, -4.87228e-34, -4.87142e-34, -4.87075e-34, -4.87027e-34, -4.86992e-34, -4.86918e-34, -4.87196e-34, -4.94112e-34, -5.45747e-34, -7.76611e-34, -2.39008e-34, -4.43465e-34, 0.0387397, 0.0743135, 0.102545, 0.119659, 0.123602, 0.11526, 0.0987263, 0.0799941, 0.0643711, 0.0541332, 0.0482031, 0.0441383, 0.040508, 0.0372921, 0.0345952, 0.0322814, 0.0302649, 0.0284915, 0.0269192, 0.0255147, 0.0242522, 0.0231108, 0.0220737, 0.0211269, 0.020259, 0.0194602, 0.0187228, 0.0180437, 0.0173848, 0.016316, 0.0126345, 2.99788e-34, -4.96897e-34, 0.0295711, 0.0608071, 0.0949965, 0.13145, 0.166126, 0.191787, 0.200789, 0.189845, 0.16358, 0.133039, 0.1088, 0.0942216, 0.0855543, 0.0784902, 0.0722191, 0.0669641, 0.0624831, 0.0585948, 0.055185, 0.0521673, 0.0494752, 0.047057, 0.0448717, 0.0428862, 0.0410737, 0.0394116, 0.0378807, 0.0364714, 0.0351561, 0.0333354, 0.0268389, 6.74592e-34, -4.86196e-34, 0.0312484, 0.0619518, 0.0920232, 0.122473, 0.155265, 0.191375, 0.227482, 0.254184, 0.259679, 0.238917, 0.200695, 0.162985, 0.138146, 0.124249, 0.113852, 0.10473, 0.0971078, 0.0906341, 0.0850356, 0.0801359, 0.0758049, 0.0719441, 0.0684772, 0.0653443, 0.0624975, 0.0598978, 0.057511, 0.0553133, 0.053288, 0.050826, 0.0421824, 1.11169e-33, -4.87707e-34, 0.0307446, 0.0616677, 0.0927184, 0.123492, 0.153648, 0.183971, 0.216798, 0.253568, 0.289432, 0.31053, 0.301802, 0.263037, 0.214654, 0.179484, 0.160182, 0.146576, 0.134834, 0.125068, 0.116795, 0.109657, 0.103418, 0.0979066, 0.0929946, 0.0885835, 0.0845963, 0.0809717, 0.0776576, 0.0746091, 0.0718008, 0.0686695, 0.0582943, 1.60137e-33, -4.8741e-34, 0.0305119, 0.0610284, 0.0916311, 0.122465, 0.153507, 0.184308, 0.214458, 0.2451, 0.279314, 0.317505, 0.349144, 0.353322, 0.31834, 0.262161, 0.217607, 0.193285, 0.176691, 0.162588, 0.150921, 0.141051, 0.132547, 0.125118, 0.118556, 0.112707, 0.107451, 0.102699, 0.098373, 0.094405, 0.0907368, 0.0868315, 0.074891, 2.13574e-33, -4.87262e-34, 0.0301965, 0.0604383, 0.0907487, 0.121147, 0.151725, 0.182637, 0.213789, 0.244544, 0.274687, 0.306585, 0.343799, 0.381159, 0.396359, 0.366683, 0.304599, 0.252067, 0.223531, 0.204266, 0.188088, 0.17477, 0.163507, 0.153807, 0.145332, 0.137844, 0.131164, 0.125159, 0.119721, 0.114753, 0.110147, 0.10533, 0.091778, 2.70977e-33, -4.87139e-34, 0.0298296, 0.0597052, 0.0896758, 0.119783, 0.150045, 0.180481, 0.211218, 0.242402, 0.273692, 0.304233, 0.33492, 0.370233, 0.410055, 0.433701, 0.408893, 0.341645, 0.282701, 0.250976, 0.22941, 0.211463, 0.196739, 0.184278, 0.173545, 0.16416, 0.155861, 0.148451, 0.141781, 0.135716, 0.130089, 0.12421, 0.108838, 3.32152e-33, -4.8701e-34, 0.0294188, 0.0588883, 0.0884574, 0.118176, 0.148092, 0.178241, 0.208623, 0.239281, 0.270401, 0.301987, 0.333176, 0.363584, 0.397169, 0.437656, 0.467453, 0.445865, 0.373323, 0.309611, 0.275754, 0.252265, 0.232861, 0.216963, 0.203489, 0.191872, 0.181703, 0.1727, 0.164648, 0.157369, 0.150622, 0.143528, 0.126009, 3.97188e-33, -4.86889e-34, 0.0289663, 0.0579873, 0.0871165, 0.116406, 0.145903, 0.175659, 0.205718, 0.236093, 0.266773, 0.297874, 0.329603, 0.361395, 0.392086, 0.424443, 0.464811, 0.499008, 0.478241, 0.399863, 0.3331, 0.298056, 0.273004, 0.252441, 0.235583, 0.221264, 0.208901, 0.198061, 0.188445, 0.179806, 0.171818, 0.163345, 0.143272, 4.66408e-33, -4.86774e-34, 0.0284768, 0.0570112, 0.0856602, 0.11448, 0.143523, 0.172839, 0.202475, 0.232479, 0.26288, 0.293653, 0.324827, 0.356656, 0.388934, 0.420187, 0.451789, 0.491892, 0.52918, 0.50633, 0.42163, 0.353592, 0.318102, 0.291814, 0.270369, 0.252738, 0.237727, 0.224739, 0.213324, 0.203144, 0.193764, 0.183727, 0.16063, 5.40307e-33, -4.86665e-34, 0.0279545, 0.0559691, 0.0841031, 0.112415, 0.140962, 0.169799, 0.198977, 0.228539, 0.258531, 0.288992, 0.31991, 0.351245, 0.383205, 0.415872, 0.447804, 0.478974, 0.519088, 0.558311, 0.530166, 0.439126, 0.371555, 0.336116, 0.30889, 0.286804, 0.268566, 0.252993, 0.239479, 0.227527, 0.216567, 0.204746, 0.178103, 6.19511e-33, -4.86563e-34, 0.027404, 0.0548698, 0.0824586, 0.110231, 0.138247, 0.166564, 0.195238, 0.22432, 0.253856, 0.283884, 0.314446, 0.34555, 0.377119, 0.409274, 0.442276, 0.474929, 0.505829, 0.546547, 0.586344, 0.549646, 0.452973, 0.387444, 0.352318, 0.324422, 0.301901, 0.283194, 0.26716, 0.253144, 0.240361, 0.226491, 0.195723, 7.04754e-33, -4.86467e-34, 0.0268297, 0.0537222, 0.08074, 0.107945, 0.1354, 0.163164, 0.191295, 0.219851, 0.248884, 0.278438, 0.308551, 0.339261, 0.370588, 0.40245, 0.434872, 0.468199, 0.501572, 0.532262, 0.574402, 0.612869, 0.564687, 0.463889, 0.40165, 0.366914, 0.338593, 0.315798, 0.29672, 0.280233, 0.265318, 0.249068, 0.21354, 7.9687e-33, -4.86379e-34, 0.0262358, 0.0525349, 0.0789604, 0.105575, 0.132442, 0.159624, 0.187181, 0.215172, 0.243656, 0.272684, 0.302304, 0.33255, 0.363454, 0.395045, 0.427249, 0.460002, 0.493689, 0.527727, 0.558284, 0.602725, 0.637206, 0.575367, 0.472624, 0.414485, 0.380093, 0.351564, 0.328596, 0.309123, 0.291657, 0.272619, 0.23162, 8.96819e-33, -4.86296e-34, 0.0256265, 0.0513163, 0.0771324, 0.103138, 0.129397, 0.155972, 0.182925, 0.210321, 0.238217, 0.266673, 0.295742, 0.325472, 0.355898, 0.387043, 0.418941, 0.451529, 0.484665, 0.51879, 0.553351, 0.584023, 0.631433, 0.65853, 0.582015, 0.479892, 0.426172, 0.392026, 0.363445, 0.340237, 0.319681, 0.297322, 0.250055, 1.00571e-32, -4.86221e-34, 0.0250057, 0.0500742, 0.0752679, 0.10065, 0.126284, 0.152233, 0.178561, 0.205332, 0.23261, 0.260455, 0.288927, 0.318081, 0.347965, 0.378615, 0.410047, 0.442296, 0.475307, 0.508869, 0.543537, 0.578383, 0.609721, 0.660199, 0.676034, 0.585224, 0.486297, 0.436853, 0.40282, 0.374134, 0.349783, 0.323428, 0.26897, 1.12488e-32, -4.86152e-34, 0.0243771, 0.0488159, 0.0733782, 0.0981263, 0.123123, 0.148431, 0.174116, 0.200242, 0.226874, 0.254076, 0.281912, 0.310442, 0.339723, 0.369803, 0.400722, 0.43248, 0.465132, 0.498592, 0.532629, 0.567944, 0.602781, 0.635678, 0.688407, 0.689106, 0.585785, 0.492275, 0.446555, 0.412316, 0.382434, 0.351276, 0.288543, 1.25591e-32, -4.86089e-34, 0.023744, 0.0475484, 0.0714737, 0.095581, 0.119932, 0.14459, 0.169618, 0.195082, 0.221048, 0.247581, 0.274748, 0.302615, 0.331243, 0.360691, 0.391006, 0.422237, 0.454356, 0.487471, 0.521389, 0.555977, 0.591984, 0.626566, 0.662159, 0.715182, 0.697454, 0.584572, 0.498014, 0.454947, 0.419003, 0.381237, 0.309022, 1.40084e-32, -4.86033e-34, 0.0231095, 0.0462777, 0.0695638, 0.0930272, 0.116728, 0.140729, 0.165093, 0.189883, 0.215167, 0.241011, 0.267484, 0.294654, 0.322589, 0.351353, 0.381006, 0.411594, 0.443184, 0.475685, 0.509342, 0.543692, 0.578955, 0.615587, 0.649866, 0.68928, 0.739493, 0.701139, 0.58232, 0.503122, 0.46003, 0.41445, 0.330665, 1.56236e-32, -4.85982e-34, 0.0224764, 0.0450097, 0.0676571, 0.0904765, 0.113527, 0.136868, 0.160562, 0.184672, 0.209264, 0.234406, 0.260165, 0.286614, 0.313822, 0.34186, 0.370794, 0.40069, 0.431582, 0.463582, 0.496467, 0.530777, 0.565489, 0.601606, 0.638662, 0.672917, 0.716897, 0.76025, 0.700407, 0.579094, 0.50507, 0.451734, 0.354241, 1.74316e-32, -4.85937e-34, 0.0218471, 0.0437492, 0.0657614, 0.0879395, 0.110341, 0.133023, 0.156047, 0.179474, 0.203369, 0.227799, 0.252833, 0.278542, 0.304998, 0.332277, 0.36045, 0.389588, 0.419762, 0.450984, 0.483456, 0.516697, 0.551818, 0.586757, 0.62396, 0.661122, 0.696016, 0.744513, 0.776246, 0.694999, 0.572287, 0.491893, 0.380568, 1.94963e-32, -4.85898e-34, 0.021224, 0.0425007, 0.0638832, 0.0854252, 0.107182, 0.129209, 0.151565, 0.17431, 0.197507, 0.221222, 0.245523, 0.270481, 0.29617, 0.322665, 0.350043, 0.378382, 0.407753, 0.43824, 0.469811, 0.502831, 0.536351, 0.572528, 0.607465, 0.64601, 0.682919, 0.719407, 0.771047, 0.785433, 0.681522, 0.548181, 0.408565, 2.19068e-32, -4.85859e-34, 0.0206089, 0.0412683, 0.062029, 0.0829424, 0.104061, 0.12544, 0.147133, 0.169201, 0.191703, 0.214704, 0.23827, 0.262471, 0.287382, 0.313078, 0.339638, 0.367144, 0.395676, 0.425305, 0.456139, 0.488068, 0.521736, 0.555386, 0.593003, 0.627553, 0.667687, 0.704024, 0.742963, 0.793927, 0.781732, 0.643303, 0.445775, 2.45898e-32, -4.85846e-34, 0.020003, 0.0400541, 0.0602018, 0.0804954, 0.100985, 0.121723, 0.142762, 0.164159, 0.185973, 0.208264, 0.231098, 0.254544, 0.278673, 0.303562, 0.329291, 0.355941, 0.383598, 0.412347, 0.442259, 0.473472, 0.505757, 0.540195, 0.573722, 0.613397, 0.6469, 0.688787, 0.724213, 0.765133, 0.805428, 0.742902, 0.510386, 2.80313e-32, -4.85759e-34, 0.0194096, 0.0388652, 0.0584129, 0.0780995, 0.0979728, 0.118082, 0.138478, 0.159215, 0.180348, 0.201937, 0.224044, 0.246736, 0.270085, 0.294164, 0.319052, 0.344833, 0.371593, 0.399421, 0.428407, 0.458617, 0.490237, 0.522861, 0.558208, 0.591216, 0.633952, 0.665225, 0.708697, 0.742091, 0.779064, 0.779049, 0.585643, 3.3682e-32, -4.85977e-34, 0.0188228, 0.0376887, 0.0566414, 0.0757256, 0.0949872, 0.114474, 0.134234, 0.154321, 0.174787, 0.195688, 0.217085, 0.23904, 0.261621, 0.2849, 0.308953, 0.333862, 0.359714, 0.386598, 0.414607, 0.443838, 0.474346, 0.506377, 0.5393, 0.575669, 0.607571, 0.654992, 0.681798, 0.725373, 0.751344, 0.758508, 0.620904, 4.06641e-32, -4.85004e-34, 0.0182697, 0.0365823, 0.0549791, 0.0735018, 0.0921919, 0.111092, 0.130247, 0.149702, 0.169509, 0.189721, 0.210397, 0.2316, 0.253396, 0.275858, 0.299059, 0.32308, 0.348002, 0.373913, 0.400903, 0.429066, 0.4585, 0.489248, 0.521617, 0.554725, 0.592085, 0.622066, 0.67671, 0.69443, 0.731651, 0.727164, 0.608646, 4.52899e-32, -4.88913e-34, 0.0176518, 0.0353372, 0.0530949, 0.0709673, 0.0890002, 0.107242, 0.125744, 0.144558, 0.163734, 0.183322, 0.203369, 0.223927, 0.245044, 0.26678, 0.289195, 0.31236, 0.336351, 0.36125, 0.387143, 0.41412, 0.442271, 0.471697, 0.502419, 0.534795, 0.567725, 0.6056, 0.632578, 0.698116, 0.695983, 0.702479, 0.579623, 4.66393e-32, -4.72399e-34, 0.0173561, 0.034768, 0.0522744, 0.069904, 0.0876768, 0.105608, 0.123712, 0.142009, 0.160532, 0.179327, 0.198457, 0.217996, 0.238027, 0.258628, 0.279877, 0.301838, 0.32457, 0.348124, 0.372554, 0.397918, 0.424282, 0.451716, 0.480308, 0.510056, 0.541341, 0.572956, 0.609746, 0.632319, 0.712962, 0.662573, 0.552443, 4.67232e-32, -5.44234e-34, 0.0158412, 0.0316482, 0.0474458, 0.0633041, 0.0793284, 0.0956477, 0.112398, 0.129701, 0.147641, 0.166245, 0.185478, 0.205255, 0.225463, 0.245996, 0.266781, 0.287796, 0.309062, 0.330637, 0.352592, 0.375008, 0.397966, 0.421549, 0.445839, 0.470938, 0.496852, 0.523945, 0.551136, 0.582841, 0.599172, 0.695654, 0.51521, 4.67889e-32, -2.10866e-34, 0.0194892, 0.0391773, 0.0592157, 0.0795502, 0.0999449, 0.120038, 0.139426, 0.157761, 0.174828, 0.190591, 0.205185, 0.218856, 0.23189, 0.244542, 0.256993, 0.269359, 0.281711, 0.294106, 0.306607, 0.319286, 0.33222, 0.345485, 0.359152, 0.373289, 0.387971, 0.403202, 0.419227, 0.435348, 0.4543, 0.462203, 0.555877, 4.66184e-32, -4.78136e-34, -1.92851e-34, -1.65034e-34, -8.68416e-35, 5.29141e-35, 2.65749e-34, 5.61332e-34, 9.45488e-34, 1.41913e-33, 1.97869e-33, 2.61802e-33, 3.33133e-33, 4.1158e-33, 4.97301e-33, 5.90853e-33, 6.93025e-33, 8.04642e-33, 9.26449e-33, 1.05911e-32, 1.2033e-32, 1.3598e-32, 1.52953e-32, 1.71357e-32, 1.91311e-32, 2.12948e-32, 2.36409e-32, 2.61859e-32, 2.89423e-32, 3.19407e-32, 3.51526e-32, 3.87231e-32, 4.23718e-32, 4.60369e-32
    });

    for (std::size_t i = 0; i < expected.size(); ++i) { EXPECT_TRUE(std::abs(pde_.solution()(i)-expected[i]) < 2e-6); }
}

TEST(transport_test, TestCase3){
    constexpr std::size_t femOrder = 1;

    // define domain
    MeshLoader<Mesh2D> domain("unit_square_32");

    // define vector field containing transport data
    VectorField<2> b_callable;
    b_callable[0] = [](SVector<2> x) -> double { return std::pow(x[1], 2) + 1; };   // y^2 + 1
    b_callable[1] = [](SVector<2> x) -> double { return 2 * x[0]; };                // 2*x

    Integrator<FEM, 2, femOrder> integrator;
    DMatrix<double> quad_nodes = integrator.quadrature_nodes(domain.mesh);
    DMatrix<double, Eigen::RowMajor> b_data(quad_nodes.rows(), 2);
    for(int i = 0; i < quad_nodes.rows(); i++) {
        b_data.row(i) = b_callable(SVector<2>(quad_nodes.row(i)));
    }

    // construct it together with its divergence
    ScalarField<2> div_b_callable = div(b_callable);
    DVector<double> div_b_data(quad_nodes.rows());
    for(int i = 0; i < quad_nodes.rows(); i++) {
        div_b_data(i) = div_b_callable(SVector<2>(quad_nodes.row(i)));
    }

    // coefficients
    DiscretizedVectorField<2,2> b_discretized(b_data, div_b_data);
    double mu = 1e-5;
    double c = 1.;

    // non-zero forcing term
    auto forcingExpr = [](SVector<2> x) -> double { return 1.; };
    ScalarField<2> forcing(forcingExpr);   // wrap lambda expression in ScalarField object

    PDEparameters<decltype(mu), decltype(b_discretized), decltype(c)> &PDEparams =
            PDEparameters<decltype(mu), decltype(b_discretized), decltype(c)>::getInstance(mu, b_discretized, c);

    // define differential operator
    auto L = -mu*laplacian<FEM>() + advection<FEM>(b_discretized) + reaction<FEM>(c);

    PDE< decltype(domain.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(mu),
            decltype(b_discretized), decltype(c)> pde_( domain.mesh, L, forcing );

    // compute boundary condition and exact solution
    DMatrix<double> nodes_ = pde_.dof_coords();
    DMatrix<double> dirichletBC(nodes_.rows(), 1);

    // set dirichlet conditions
    for (int i = 0; i < nodes_.rows(); ++i) {
        dirichletBC(i) = 0.;
    }
    pde_.set_dirichlet_bc(dirichletBC);
    pde_.set_stab_param(2.85);

    // init solver and solve differential problem
    pde_.init();
    pde_.solve();

//    //storing solution
//    std::ofstream file("fdaPDE_SUPG_sol.txt");
//    if (file.is_open()){
//        for(int i = 0; i < pde_.solution().rows(); ++i)
//            file << pde_.solution()(i) << '\n';
//        file.close();
//    } else {
//        std::cerr << "transport test unable to save solution" << std::endl;
//    }

    std::vector<double> expected({
        -4.89124e-34, -1.87828e-34, -2.4369e-34, -3.25796e-34, -4.12076e-34, -4.82832e-34, -5.25428e-34, -5.3757e-34, -5.2725e-34, -5.08361e-34, -4.93418e-34, -4.8745e-34, -4.87246e-34, -4.87278e-34, -4.86516e-34, -4.85981e-34, -4.85655e-34, -4.85431e-34, -4.85283e-34, -4.85189e-34, -4.85135e-34, -4.8511e-34, -4.85106e-34, -4.8512e-34, -4.85153e-34, -4.85221e-34, -4.85435e-34, -4.86554e-34, -4.92855e-34, -5.22509e-34, -6.3336e-34, -9.59319e-34, -2.98106e-34, -4.19334e-34, 0.0376006, 0.0709936, 0.0965548, 0.111378, 0.114314, 0.10673, 0.0924019, 0.0762851, 0.0625692, 0.053096, 0.0472152, 0.0431447, 0.0396657, 0.0366025, 0.0340006, 0.0317622, 0.0298081, 0.0280865, 0.0265574, 0.0251896, 0.0239584, 0.0228439, 0.0218301, 0.0209036, 0.0200532, 0.0192686, 0.018537, 0.0178168, 0.0169226, 0.0151687, 0.0106855, 4.09027e-34, -4.96004e-34, 0.0294814, 0.0595961, 0.0912857, 0.123641, 0.153033, 0.173661, 0.18002, 0.170383, 0.148892, 0.123997, 0.103553, 0.0903392, 0.0820223, 0.0754322, 0.0696645, 0.0647657, 0.0605646, 0.0569052, 0.0536847, 0.0508252, 0.048267, 0.0459633, 0.0438765, 0.0419764, 0.0402378, 0.0386385, 0.037154, 0.035723, 0.0340603, 0.030956, 0.0225377, 7.61113e-34, -4.83843e-34, 0.0306283, 0.0598896, 0.0878819, 0.115575, 0.144464, 0.174893, 0.203733, 0.223706, 0.226649, 0.209864, 0.180227, 0.150495, 0.12962, 0.116959, 0.107546, 0.0994207, 0.0925342, 0.08664, 0.0815127, 0.0770022, 0.0729969, 0.0694116, 0.0661803, 0.0632504, 0.0605791, 0.0581294, 0.0558628, 0.0537028, 0.0513103, 0.0470955, 0.035223, 1.16663e-33, -4.84731e-34, 0.03031, 0.0598175, 0.088463, 0.115976, 0.142285, 0.168233, 0.195552, 0.224736, 0.251485, 0.265792, 0.258003, 0.228962, 0.192755, 0.164938, 0.148206, 0.136278, 0.126127, 0.117554, 0.110223, 0.10385, 0.0982421, 0.0932593, 0.0887951, 0.0847671, 0.0811097, 0.0777672, 0.0746838, 0.0717632, 0.0686266, 0.0634053, 0.0484359, 1.6179e-33, -4.84729e-34, 0.0300454, 0.0592123, 0.0875967, 0.115296, 0.142242, 0.168124, 0.192877, 0.217633, 0.244444, 0.272707, 0.294347, 0.295632, 0.270001, 0.229723, 0.196181, 0.175985, 0.161903, 0.150049, 0.140073, 0.131545, 0.124129, 0.117599, 0.11179, 0.10658, 0.101871, 0.0975847, 0.0936432, 0.0899234, 0.0860002, 0.0797756, 0.0619217, 2.10806e-33, -4.84574e-34, 0.0297438, 0.0586407, 0.0867415, 0.114102, 0.140815, 0.166963, 0.192396, 0.21672, 0.240133, 0.264535, 0.291761, 0.317122, 0.325756, 0.304263, 0.261376, 0.223407, 0.200541, 0.184699, 0.171454, 0.160338, 0.150829, 0.142553, 0.135256, 0.128756, 0.122915, 0.117623, 0.112774, 0.10821, 0.103443, 0.0961514, 0.0754851, 2.6319e-33, -4.84488e-34, 0.0293883, 0.0579571, 0.0857698, 0.112877, 0.139317, 0.165141, 0.19045, 0.215272, 0.239283, 0.262103, 0.28481, 0.310217, 0.336922, 0.350871, 0.332955, 0.288042, 0.246855, 0.222155, 0.204945, 0.1906, 0.178583, 0.168286, 0.15931, 0.151384, 0.144309, 0.137933, 0.132115, 0.126655, 0.120978, 0.112515, 0.088988, 3.18627e-33, -4.84405e-34, 0.0289891, 0.0571858, 0.0846559, 0.111459, 0.137644, 0.163246, 0.188287, 0.212831, 0.236979, 0.260597, 0.283126, 0.304804, 0.328433, 0.355187, 0.372716, 0.357134, 0.310197, 0.266895, 0.241139, 0.222916, 0.207739, 0.195028, 0.184111, 0.174576, 0.166136, 0.158579, 0.151717, 0.145295, 0.138636, 0.128871, 0.102341, 3.77009e-33, -4.8433e-34, 0.0285497, 0.056336, 0.0834268, 0.109883, 0.135757, 0.161095, 0.185931, 0.210276, 0.234152, 0.257655, 0.280806, 0.303111, 0.324201, 0.346357, 0.372595, 0.392393, 0.377566, 0.328355, 0.283966, 0.257807, 0.238876, 0.223102, 0.209876, 0.198484, 0.188507, 0.179642, 0.17164, 0.164178, 0.156449, 0.145237, 0.115491, 4.38416e-33, -4.84264e-34, 0.028074, 0.0554145, 0.0820912, 0.108167, 0.133695, 0.158724, 0.183292, 0.207431, 0.231153, 0.25445, 0.277378, 0.300039, 0.3221, 0.342852, 0.363852, 0.389455, 0.410534, 0.394735, 0.343031, 0.298525, 0.272463, 0.253074, 0.236905, 0.223313, 0.211563, 0.201227, 0.191963, 0.18336, 0.174459, 0.161636, 0.128415, 5.03078e-33, -4.84207e-34, 0.0275663, 0.0544296, 0.0806609, 0.106324, 0.131475, 0.156162, 0.180427, 0.204302, 0.227814, 0.250975, 0.273767, 0.296198, 0.31839, 0.340177, 0.360714, 0.380803, 0.405924, 0.427428, 0.408916, 0.354741, 0.311013, 0.285383, 0.265737, 0.249339, 0.235498, 0.223468, 0.212782, 0.202912, 0.192713, 0.178097, 0.141105, 5.71343e-33, -4.84159e-34, 0.0270308, 0.0533896, 0.0791478, 0.10437, 0.129113, 0.153428, 0.177358, 0.200937, 0.224193, 0.247145, 0.269806, 0.292153, 0.314159, 0.335927, 0.357423, 0.377799, 0.397143, 0.422097, 0.443114, 0.420275, 0.364, 0.321822, 0.296814, 0.277068, 0.260566, 0.246548, 0.234225, 0.222923, 0.211271, 0.194655, 0.153568, 6.4365e-33, -4.84119e-34, 0.0264719, 0.0523027, 0.0775639, 0.10232, 0.12663, 0.150544, 0.174108, 0.197359, 0.220326, 0.243031, 0.265489, 0.287705, 0.309662, 0.331304, 0.352699, 0.373911, 0.394132, 0.412859, 0.438037, 0.457445, 0.428961, 0.371315, 0.331282, 0.306965, 0.287235, 0.270699, 0.256461, 0.243509, 0.23021, 0.211354, 0.165822, 7.20508e-33, -4.84087e-34, 0.0258936, 0.0511769, 0.075921, 0.10019, 0.124043, 0.147532, 0.170703, 0.193594, 0.21624, 0.238664, 0.260884, 0.282906, 0.304731, 0.326347, 0.347676, 0.368752, 0.389704, 0.409733, 0.427998, 0.453747, 0.470159, 0.435176, 0.377167, 0.339653, 0.316002, 0.296345, 0.279704, 0.264825, 0.249628, 0.228249, 0.177893, 8.02497e-33, -4.84063e-34, 0.0252999, 0.05002, 0.0742302, 0.0979947, 0.121372, 0.144413, 0.167167, 0.189672, 0.211966, 0.234074, 0.256019, 0.277812, 0.299455, 0.32094, 0.342262, 0.363317, 0.384125, 0.404857, 0.424618, 0.442661, 0.469145, 0.480953, 0.439206, 0.381975, 0.347116, 0.324016, 0.30433, 0.287062, 0.269658, 0.245417, 0.189822, 8.90271e-33, -4.84046e-34, 0.0246947, 0.0488393, 0.0725026, 0.0957477, 0.118632, 0.141208, 0.163524, 0.18562, 0.207534, 0.229297, 0.250931, 0.272455, 0.293875, 0.315191, 0.336379, 0.357458, 0.378266, 0.398858, 0.419409, 0.438802, 0.456981, 0.484038, 0.48956, 0.441418, 0.386067, 0.353734, 0.33089, 0.310549, 0.290467, 0.262961, 0.201663, 9.84585e-33, -4.84036e-34, 0.0240814, 0.0476418, 0.0707484, 0.0934628, 0.115842, 0.137938, 0.159798, 0.181464, 0.202976, 0.224365, 0.245658, 0.266876, 0.288032, 0.309129, 0.330166, 0.351094, 0.371983, 0.392555, 0.412994, 0.433385, 0.452317, 0.471092, 0.498114, 0.495809, 0.442208, 0.389604, 0.359307, 0.335831, 0.312326, 0.281015, 0.213492, 1.08632e-32, -4.84033e-34, 0.0234634, 0.046434, 0.068977, 0.0911526, 0.113017, 0.13462, 0.15601, 0.17723, 0.198319, 0.219311, 0.240235, 0.261115, 0.281969, 0.302806, 0.323625, 0.344428, 0.365123, 0.385887, 0.406212, 0.426578, 0.446788, 0.465233, 0.485077, 0.510972, 0.49964, 0.441886, 0.392388, 0.362834, 0.335749, 0.299785, 0.225407, 1.19655e-32, -4.84035e-34, 0.0228436, 0.0452217, 0.0671972, 0.0888287, 0.11017, 0.131273, 0.152182, 0.172942, 0.193591, 0.214165, 0.234696, 0.25521, 0.275728, 0.296265, 0.316828, 0.337408, 0.358025, 0.378498, 0.399221, 0.419255, 0.439649, 0.45961, 0.47765, 0.498912, 0.522134, 0.501019, 0.440395, 0.393248, 0.360719, 0.319713, 0.237548, 1.31659e-32, -4.84043e-34, 0.0222248, 0.0440103, 0.0654171, 0.0865018, 0.107317, 0.127912, 0.148332, 0.168621, 0.188817, 0.208957, 0.229074, 0.249197, 0.269351, 0.289553, 0.309816, 0.330145, 0.35052, 0.371001, 0.391242, 0.41204, 0.431698, 0.452241, 0.471834, 0.48968, 0.512399, 0.530991, 0.499622, 0.436555, 0.388051, 0.340862, 0.250224, 1.44799e-32, -4.84056e-34, 0.0216094, 0.0428046, 0.0636438, 0.0841814, 0.104468, 0.124552, 0.144478, 0.164288, 0.184021, 0.203714, 0.223401, 0.243112, 0.262875, 0.282712, 0.302639, 0.322667, 0.342799, 0.362997, 0.383396, 0.403368, 0.424406, 0.443542, 0.464359, 0.483436, 0.501372, 0.52503, 0.536502, 0.493937, 0.425815, 0.363448, 0.263555, 1.59402e-32, -4.84073e-34, 0.0209996, 0.0416089, 0.0618836, 0.0818761, 0.101635, 0.121207, 0.140635, 0.159961, 0.179224, 0.19846, 0.217704, 0.236987, 0.256338, 0.275784, 0.295343, 0.315033, 0.334859, 0.354829, 0.374872, 0.395248, 0.414876, 0.436394, 0.45477, 0.475968, 0.494348, 0.512542, 0.535607, 0.536208, 0.478685, 0.393587, 0.277476, 1.75712e-32, -4.84095e-34, 0.0203972, 0.0404269, 0.0601423, 0.0795934, 0.0988272, 0.117888, 0.136818, 0.155658, 0.174446, 0.193218, 0.212008, 0.23085, 0.249774, 0.268806, 0.287972, 0.307289, 0.326773, 0.346427, 0.366264, 0.386165, 0.406583, 0.425741, 0.448091, 0.465317, 0.486925, 0.504313, 0.522321, 0.541152, 0.523374, 0.437588, 0.295549, 1.93563e-32, -4.8412e-34, 0.0198038, 0.0392618, 0.0584247, 0.07734, 0.0960527, 0.114606, 0.133039, 0.151393, 0.169703, 0.188007, 0.206338, 0.224729, 0.243211, 0.261813, 0.280562, 0.299479, 0.318582, 0.337885, 0.357389, 0.377113, 0.396873, 0.417394, 0.435896, 0.459595, 0.475015, 0.496822, 0.512459, 0.527974, 0.533846, 0.479163, 0.32308, 2.15684e-32, -4.84145e-34, 0.0192209, 0.0381167, 0.0567352, 0.0751218, 0.0933193, 0.111369, 0.129309, 0.147178, 0.165012, 0.182845, 0.200712, 0.218646, 0.236676, 0.254833, 0.273144, 0.291634, 0.310324, 0.329231, 0.348364, 0.36772, 0.387332, 0.406931, 0.427584, 0.445168, 0.470962, 0.483418, 0.504553, 0.516124, 0.521738, 0.492827, 0.351599, 2.47536e-32, -4.84201e-34, 0.0186493, 0.0369927, 0.0550759, 0.0729417, 0.0906311, 0.108183, 0.125635, 0.143023, 0.160381, 0.177745, 0.195145, 0.212615, 0.230184, 0.247881, 0.265734, 0.283769, 0.302006, 0.320465, 0.339159, 0.358096, 0.377265, 0.396713, 0.416075, 0.436806, 0.453123, 0.482049, 0.489378, 0.507152, 0.507764, 0.482604, 0.362849, 2.83694e-32, -4.84081e-34, 0.0180922, 0.0358969, 0.0534572, 0.0708136, 0.0880047, 0.105068, 0.122037, 0.138948, 0.155833, 0.172724, 0.189652, 0.206646, 0.223735, 0.240947, 0.258305, 0.275834, 0.293555, 0.311483, 0.329635, 0.348017, 0.366632, 0.385462, 0.404566, 0.423489, 0.444052, 0.458652, 0.492033, 0.489928, 0.496844, 0.467089, 0.355511, 3.08284e-32, -4.85093e-34, 0.017536, 0.0348023, 0.051839, 0.0686848, 0.0853766, 0.10195, 0.118438, 0.134873, 0.151285, 0.167701, 0.184146, 0.200644, 0.217217, 0.233884, 0.250666, 0.267579, 0.284638, 0.301856, 0.319244, 0.336809, 0.354553, 0.372474, 0.390544, 0.408835, 0.42683, 0.446597, 0.458912, 0.498143, 0.477498, 0.453733, 0.341619, 3.18089e-32, -4.78678e-34, 0.0170693, 0.0338815, 0.0504768, 0.0668891, 0.0831481, 0.0992801, 0.115309, 0.131257, 0.147147, 0.162996, 0.178825, 0.194647, 0.210477, 0.226326, 0.242203, 0.258117, 0.274074, 0.29008, 0.30614, 0.322255, 0.338428, 0.35466, 0.370949, 0.387265, 0.403689, 0.419702, 0.437383, 0.446719, 0.492436, 0.433151, 0.328228, 3.22171e-32, -5.23207e-34, 0.0161351, 0.0320574, 0.047785, 0.0633522, 0.0787977, 0.094159, 0.109467, 0.124743, 0.13999, 0.155196, 0.170325, 0.18533, 0.200153, 0.214744, 0.229069, 0.243112, 0.256881, 0.270403, 0.283708, 0.296833, 0.309807, 0.322659, 0.335409, 0.348073, 0.36064, 0.373193, 0.385299, 0.398696, 0.404316, 0.454024, 0.310642, 3.26127e-32, -2.16596e-34, 0.0184132, 0.0364052, 0.05409, 0.0714199, 0.0882234, 0.104259, 0.119279, 0.133092, 0.145604, 0.156839, 0.166924, 0.176052, 0.184431, 0.192251, 0.199654, 0.206737, 0.213561, 0.220168, 0.226594, 0.232877, 0.23905, 0.245144, 0.251184, 0.257187, 0.263168, 0.269116, 0.275086, 0.280805, 0.287275, 0.288907, 0.331025, 3.28806e-32, -5.96362e-34, -1.79294e-34, -1.5066e-34, -7.13229e-35, 6.76124e-35, 2.74725e-34, 5.5655e-34, 9.16203e-34, 1.35284e-33, 1.8622e-33, 2.43818e-33, 3.07484e-33, 3.76828e-33, 4.51752e-33, 5.32433e-33, 6.19221e-33, 7.12507e-33, 8.12633e-33, 9.1987e-33, 1.03445e-32, 1.1566e-32, 1.28661e-32, 1.42479e-32, 1.57149e-32, 1.72706e-32, 1.89185e-32, 2.06618e-32, 2.2502e-32, 2.44463e-32, 2.64746e-32, 2.86527e-32, 3.08132e-32, 3.28433e-32
    });

    for (std::size_t i = 0; i < expected.size(); ++i) { EXPECT_TRUE(std::abs(pde_.solution()(i)-expected[i]) < 2e-6); }
}

TEST(transport_test, TestCase4) {
    constexpr std::size_t femOrder = 2;

    // define exact solution
    auto solutionExpr = [](SVector<2> x) -> double {
        return 3*sin(x[0]) + 2*x[1];
    };

    SVector<2> b;  b << 1., 1.;
    double mu = 1e-1;

    // non-zero forcing term
    auto forcingExpr = [&mu, &b](SVector<2> x) -> double {
        return 2*b[1] + 3*b[0]*cos(x[0]) + 3*mu*sin(x[0]);
    };
    ScalarField<2> forcing(forcingExpr);   // wrap lambda expression in ScalarField object

    // save parameters in the PDEparameters singleton, these will be retrieved by the solver
    PDEparameters<decltype(mu), decltype(b)>::destroyInstance();
    PDEparameters<decltype(mu), decltype(b)> &PDEparams =
            PDEparameters<decltype(mu), decltype(b)>::getInstance(mu, b);

    auto L = - mu * laplacian<FEM>() + advection<FEM>(b);
    MeshLoader<Mesh2D> unit_square("unit_square_16");

    PDE< decltype(unit_square.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(mu),
            decltype(b)> pde_( unit_square.mesh, L, forcing);

    // compute boundary condition and exact solution
    DMatrix<double> nodes_ = pde_.dof_coords();
    DMatrix<double> dirichletBC(nodes_.rows(), 1);
    DMatrix<double> solution_ex(nodes_.rows(), 1);

    // set exact sol & dirichlet conditions
    for (int i = 0; i < nodes_.rows(); ++i) {
        solution_ex(i) = solutionExpr(nodes_.row(i));
        dirichletBC(i) = solutionExpr(nodes_.row(i));
    }
    pde_.set_dirichlet_bc(dirichletBC);
    pde_.set_stab_param(1.0);
    // init solver and solve differential problem
    pde_.init();
    pde_.solve();

    // check computed error
    DMatrix<double> error_ = solution_ex - pde_.solution();
    double error_L2 = (pde_.mass() * error_.cwiseProduct(error_)).sum();
    EXPECT_TRUE(error_L2 < 1e-7);

    // // storing solution
    // std::ofstream file("fdaPDE_sol.txt");
    // if (file.is_open()){
    //     for(int i = 0; i < pde_.solution().rows(); ++i)
    //         file << pde_.solution()(i) << '\n';
    //     file.close();
    // } else {
    //     std::cerr << "transport test unable to save solution" << std::endl;
    // }
}

// _______________ convergence tests _______________
TEST(transport_test, convergence_test_0) {
    constexpr std::size_t femOrder = 1;

    int num_refinements = 4;
    DMatrix<int> N(num_refinements, 1);   // number of refinements
    N << 16, 32, 64, 128;
    DMatrix<double> order(num_refinements - 1, 1);
    DVector<double> error_L2(num_refinements);
    error_L2.setZero();

    // define PDE parameters
    VectorField<2> b_callable;
    b_callable[0] = [](SVector<2> x) -> double { return std::pow(x[1], 2) + 1; };   // y^2 + 1
    b_callable[1] = [](SVector<2> x) -> double { return 2 * x[0]; };                // 2*x

    double nu = 1e-9;
    double c = 1.;

    constexpr double pi = 3.14159265358979323846;
    auto solutionExpr = [&pi](SVector<2> x) -> double {
        return std::sin(2 * pi * x[0]) * std::sin(2 * pi * x[1]);
    };
    auto forcingExpr = [&pi, &b_callable, &nu, &c](SVector<2> x) -> double {
        return 2*pi*b_callable[0](x)*std::sin(2*pi*x[1])*std::cos(2*pi*x[0])
            + 2*pi*b_callable[1](x)*std::sin(2*pi*x[0])*std::cos(2*pi*x[1])
            + c*std::sin(2*pi*x[0])*std::sin(2*pi*x[1]) + 8*pi*pi*nu*std::sin(2*pi*x[0])*sin(2*pi*x[1]);
    };
    ScalarField<2> forcing(forcingExpr);

    for (int n = 0; n < num_refinements; ++n) {
        std::string domain_name = "unit_square_" + std::to_string(N(n));
        MeshLoader<Mesh2D> domain(domain_name);

        // dicretize b_callable -> discretized_vector_field
        Integrator<FEM, 2, femOrder> integrator;
        DMatrix<double> quad_nodes = integrator.quadrature_nodes(domain.mesh);
        DMatrix<double, Eigen::RowMajor> b_data(quad_nodes.rows(), 2);
        for(int i = 0; i < quad_nodes.rows(); i++) {
            b_data.row(i) = b_callable(SVector<2>(quad_nodes.row(i)));
        }

        // construct discretized transport field together with its divergence
        ScalarField<2> div_b_callable = div(b_callable);
        DVector<double> div_b_data(quad_nodes.rows());
        for(int i = 0; i < quad_nodes.rows(); i++) {
            div_b_data(i) = div_b_callable(SVector<2>(quad_nodes.row(i)));
        }

        DiscretizedVectorField<2,2> b_discretized(b_data, div_b_data);

        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::destroyInstance();
        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)> &PDEparams =
                PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::getInstance(nu, b_discretized, c);

        // define differential operator
        auto L = -nu*laplacian<FEM>() + advection<FEM>(b_discretized) + reaction<FEM>(c);

        // PDE<decltype(unit_square.mesh), decltype(L), DMatrix<double>, FEM, fem_order<1>> pde_(unit_square.mesh, times);
        PDE< decltype(domain.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(nu),
            decltype(b_discretized), decltype(c)> pde_( domain.mesh, L, forcing );

        // compute boundary condition and exact solution
        DMatrix<double> nodes_ = pde_.dof_coords();
        DMatrix<double> dirichletBC(nodes_.rows(), 1);

        DMatrix<double> solution_ex(nodes_.rows(), 1);

        // set dirichlet conditions
        for (int i = 0; i < nodes_.rows(); ++i) {
            solution_ex(i) = solutionExpr(nodes_.row(i));
            dirichletBC(i) = solutionExpr(nodes_.row(i));
        }
        pde_.set_dirichlet_bc(dirichletBC);
        pde_.set_stab_param(2.);

        // init solver and solve differential problem
        pde_.init();
        pde_.solve();

        // check computed error
        DMatrix<double> error_ = solution_ex - pde_.solution();
        error_L2(n) = (pde_.mass() * error_.cwiseProduct(error_)).sum();

        std::cout << "error_L2 = " << std::setprecision(17) << error_L2(n) << std::endl;
        // //storing solution
        // std::ofstream file("fdaPDE_SUPG_sol.txt");
        // if (file.is_open()){
        //     for(int i = 0; i < pde_.solution().rows(); ++i)
        //         file << pde_.solution()(i) << '\n';
        //     file.close();
        // } else {
        //     std::cerr << "transport test unable to save solution" << std::endl;
        // }
    } // end refinement loop

    for (int nn = 1; nn < num_refinements; ++nn) {
        order(nn - 1) = std::log2(error_L2(nn - 1) / error_L2(nn));
        EXPECT_TRUE(floor(order(nn - 1)) >= 1);
    }
}

TEST(transport_test, convergence_test_1) {
    constexpr std::size_t femOrder = 1;
    double stabParam = 4.705;
    int num_refinements = 4;
    DMatrix<int> N(num_refinements, 1);   // number of refinements
    N << 16, 32, 64, 128;
    DMatrix<double> order(num_refinements - 1, 1);
    DVector<double> error_L2(num_refinements);
    error_L2.setZero();

    // define PDE parameters
    VectorField<2> b_callable;
    b_callable[0] = [](SVector<2> x) -> double { return std::pow(x[1], 2) + 1; };   // y^2 + 1
    b_callable[1] = [](SVector<2> x) -> double { return 2 * x[0]; };                // 2*x

    double nu = 1e-9;
    double c = 1.;

    // define exact solution and forcing
    double BL = 0.1;   // parameter for boundary layer thickness
    auto solutionExpr = [&nu, &BL](SVector<2> x) -> double {
        return x[0]*x[1]*x[1] - x[1]*x[1]*exp((2*(x[0] - 1))/BL) - x[0]*exp(3*(x[1] - 1)/BL) + exp((2*(x[0] - 1) + 3*(x[1] - 1))/BL);
    };
    auto forcingExpr = [&nu, &BL, &b_callable, &c](SVector<2> x) -> double {
        return (BL*BL*c*(x[0]*x[1]*x[1] - x[0]*exp(3*(x[1] - 1)/BL) - x[1]*x[1]*exp(2*(x[0] - 1)/BL) + exp((2*x[0] + 3*x[1] - 5)/BL))
            + BL*(b_callable[0](x)*(BL*(x[1]*x[1] - exp(3*(x[1] - 1)/BL)) - 2*x[1]*x[1]*exp(2*(x[0] - 1)/BL) + 2*exp((2*x[0] + 3*x[1] - 5)/BL))
            + b_callable[1](x)*(2*BL*x[1]*(x[0] - exp(2*(x[0] - 1)/BL)) - 3*x[0]*exp(3*(x[1] - 1)/BL) + 3*exp((2*x[0] + 3*x[1] - 5)/BL)))
            + nu*(2*BL*BL*(-x[0] + exp(2*(x[0] - 1)/BL)) + 9*x[0]*exp(3*(x[1] - 1)/BL) + 4*x[1]*x[1]*exp(2*(x[0] - 1)/BL)
            - 13*exp((2*x[0] + 3*x[1] - 5)/BL)))/(BL*BL);
    };
    ScalarField<2> forcing(forcingExpr);

    for (int n = 0; n < num_refinements; ++n) {
        std::string domain_name = "unit_square_" + std::to_string(N(n));
        MeshLoader<Mesh2D> domain(domain_name);

        // dicretize b_callable -> discretized_vector_field
        Integrator<FEM, 2, femOrder> integrator;
        DMatrix<double> quad_nodes = integrator.quadrature_nodes(domain.mesh);
        DMatrix<double, Eigen::RowMajor> b_data(quad_nodes.rows(), 2);
        for(int i = 0; i < quad_nodes.rows(); i++) {
            b_data.row(i) = b_callable(SVector<2>(quad_nodes.row(i)));
        }

        // construct discretized transport field together with its divergence
        ScalarField<2> div_b_callable = div(b_callable);
        DVector<double> div_b_data(quad_nodes.rows());
        for(int i = 0; i < quad_nodes.rows(); i++) {
            div_b_data(i) = div_b_callable(SVector<2>(quad_nodes.row(i)));
        }

        DiscretizedVectorField<2,2> b_discretized(b_data, div_b_data);

        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::destroyInstance();
        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)> &PDEparams =
                PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::getInstance(nu, b_discretized, c);

        // define differential operator
        auto L = -nu*laplacian<FEM>() + advection<FEM>(b_discretized) + reaction<FEM>(c);

        // PDE<decltype(unit_square.mesh), decltype(L), DMatrix<double>, FEM, fem_order<1>> pde_(unit_square.mesh, times);
        PDE< decltype(domain.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(nu),
            decltype(b_discretized), decltype(c)> pde_( domain.mesh, L, forcing );

        // compute boundary condition and exact solution
        DMatrix<double> nodes_ = pde_.dof_coords();
        DMatrix<double> dirichletBC(nodes_.rows(), 1);

        DMatrix<double> solution_ex(nodes_.rows(), 1);

        // set dirichlet conditions
        for (int i = 0; i < nodes_.rows(); ++i) {
            solution_ex(i) = solutionExpr(nodes_.row(i));
            dirichletBC(i) = solutionExpr(nodes_.row(i));
        }
        pde_.set_dirichlet_bc(dirichletBC);
        pde_.set_stab_param(stabParam);

        // init solver and solve differential problem
        pde_.init();
        pde_.solve();

        // check computed error
        DMatrix<double> error_ = solution_ex - pde_.solution();
        error_L2(n) = (pde_.mass() * error_.cwiseProduct(error_)).sum();

        // //storing solution
        // std::ofstream file("fdaPDE_SUPG_sol.txt");
        // if (file.is_open()){
        //     for(int i = 0; i < pde_.solution().rows(); ++i)
        //         file << pde_.solution()(i) << '\n';
        //     file.close();
        // } else {
        //     std::cerr << "transport test unable to save solution" << std::endl;
        // }
        // }
    } // end refinement loop

    for (int n = 1; n < num_refinements; ++n) {
        order(n - 1) = std::log2(error_L2(n - 1) / error_L2(n));
        EXPECT_TRUE(floor(order(n - 1)) >= 1);
    }
}

TEST(transport_test, convergence_test_2) {
    constexpr std::size_t femOrder = 2;
    double stabParam = 4.705;
    int num_refinements = 3;
    DMatrix<int> N(num_refinements, 1);   // number of refinements
    N << 16, 32, 64;
    DMatrix<double> order(num_refinements - 1, 1);
    DVector<double> error_L2(num_refinements);
    error_L2.setZero();

    // define PDE parameters
    VectorField<2> b_callable;
    b_callable[0] = [](SVector<2> x) -> double { return std::pow(x[1], 2) + 1; };   // y^2 + 1
    b_callable[1] = [](SVector<2> x) -> double { return 2 * x[0]; };                // 2*x

    double nu = 1e-3;
    double c = 1.;

    // define exact solution and forcing
    double BL = 0.1;   // parameter for boundary layer thickness
    auto solutionExpr = [&nu, &BL](SVector<2> x) -> double {
        return x[0]*x[1]*x[1] - x[1]*x[1]*exp((2*(x[0] - 1))/BL) - x[0]*exp(3*(x[1] - 1)/BL) + exp((2*(x[0] - 1) + 3*(x[1] - 1))/BL);
    };
    auto forcingExpr = [&nu, &BL, &b_callable, &c](SVector<2> x) -> double {
        return (BL*BL*c*(x[0]*x[1]*x[1] - x[0]*exp(3*(x[1] - 1)/BL) - x[1]*x[1]*exp(2*(x[0] - 1)/BL) + exp((2*x[0] + 3*x[1] - 5)/BL))
            + BL*(b_callable[0](x)*(BL*(x[1]*x[1] - exp(3*(x[1] - 1)/BL)) - 2*x[1]*x[1]*exp(2*(x[0] - 1)/BL) + 2*exp((2*x[0] + 3*x[1] - 5)/BL))
            + b_callable[1](x)*(2*BL*x[1]*(x[0] - exp(2*(x[0] - 1)/BL)) - 3*x[0]*exp(3*(x[1] - 1)/BL) + 3*exp((2*x[0] + 3*x[1] - 5)/BL)))
            + nu*(2*BL*BL*(-x[0] + exp(2*(x[0] - 1)/BL)) + 9*x[0]*exp(3*(x[1] - 1)/BL) + 4*x[1]*x[1]*exp(2*(x[0] - 1)/BL)
            - 13*exp((2*x[0] + 3*x[1] - 5)/BL)))/(BL*BL);
    };
    ScalarField<2> forcing(forcingExpr);

    for (int n = 0; n < num_refinements; ++n) {
        std::string domain_name = "unit_square_" + std::to_string(N(n));
        MeshLoader<Mesh2D> domain(domain_name);

        // dicretize b_callable -> discretized_vector_field
        Integrator<FEM, 2, femOrder> integrator;
        DMatrix<double> quad_nodes = integrator.quadrature_nodes(domain.mesh);
        DMatrix<double, Eigen::RowMajor> b_data(quad_nodes.rows(), 2);
        for(int i = 0; i < quad_nodes.rows(); i++) {
            b_data.row(i) = b_callable(SVector<2>(quad_nodes.row(i)));
        }

        // construct discretized transport field together with its divergence
        ScalarField<2> div_b_callable = div(b_callable);
        DVector<double> div_b_data(quad_nodes.rows());
        for(int i = 0; i < quad_nodes.rows(); i++) {
            div_b_data(i) = div_b_callable(SVector<2>(quad_nodes.row(i)));
        }

        DiscretizedVectorField<2,2> b_discretized(b_data, div_b_data);

        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::destroyInstance();
        PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)> &PDEparams =
                PDEparameters<decltype(nu), decltype(b_discretized), decltype(c)>::getInstance(nu, b_discretized, c);

        // define differential operator
        auto L = -nu*laplacian<FEM>() + advection<FEM>(b_discretized) + reaction<FEM>(c);

        PDE< decltype(domain.mesh), decltype(L), ScalarField<2>, FEM, fem_order<femOrder>, decltype(nu),
            decltype(b_discretized), decltype(c)> pde_( domain.mesh, L, forcing );

        // compute boundary condition and exact solution
        DMatrix<double> nodes_ = pde_.dof_coords();
        DMatrix<double> dirichletBC(nodes_.rows(), 1);

        DMatrix<double> solution_ex(nodes_.rows(), 1);

        // set dirichlet conditions
        for (int i = 0; i < nodes_.rows(); ++i) {
            solution_ex(i) = solutionExpr(nodes_.row(i));
            dirichletBC(i) = solutionExpr(nodes_.row(i));
        }
        pde_.set_dirichlet_bc(dirichletBC);
        pde_.set_stab_param(stabParam);

        // init solver and solve differential problem
        pde_.init();
        pde_.solve();

        // check computed error
        DMatrix<double> error_ = solution_ex - pde_.solution();
        error_L2(n) = (pde_.mass() * error_.cwiseProduct(error_)).sum();

        // std::cout << "error_L2 = " << std::setprecision(17) << error_L2(n) << std::endl;
        // //storing solution
        // std::ofstream file("fdaPDE_SUPG_sol.txt");
        // if (file.is_open()){
        //     for(int i = 0; i < pde_.solution().rows(); ++i)
        //         file << pde_.solution()(i) << '\n';
        //     file.close();
        // } else {
        //     std::cerr << "transport test unable to save solution" << std::endl;
        // }
    } // end refinement loop

    for (int n = 1; n < num_refinements; ++n) {
        order(n - 1) = std::log2(error_L2(n - 1) / error_L2(n));
        EXPECT_TRUE(floor(order(n - 1)) >= 2);
    }
}

*/